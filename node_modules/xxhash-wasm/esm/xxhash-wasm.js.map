{"version":3,"file":"xxhash-wasm.js","sources":["../src/index.js"],"sourcesContent":["// The .wasm is filled in by the build process, so the user doesn't need to load\n// xxhash.wasm by themselves because it's part of the bundle. Otherwise it\n// couldn't be distributed easily as the user would need to host xxhash.wasm\n// and then fetch it, to be able to use it.\n// eslint-disable-next-line no-undef\nconst wasmBytes = new Uint8Array(WASM_PRECOMPILED_BYTES);\n\nconst u32_BYTES = 4;\nconst u64_BYTES = 8;\n\n// The xxh32 hash state struct:\nconst XXH32_STATE_SIZE_BYTES =\n  u32_BYTES + // total_len\n  u32_BYTES + // large_len\n  u32_BYTES * 4 + // Accumulator lanes\n  u32_BYTES * 4 + // Internal buffer\n  u32_BYTES + // memsize\n  u32_BYTES; // reserved\n\n// The xxh64 hash state struct:\nconst XXH64_STATE_SIZE_BYTES =\n  u64_BYTES + // total_len\n  u64_BYTES * 4 + // Accumulator lanes\n  u64_BYTES * 4 + // Internal buffer\n  u32_BYTES + // memsize\n  u32_BYTES + // reserved32\n  u64_BYTES; // reserved64\n\nasync function xxhash() {\n  const {\n    instance: {\n      exports: {\n        mem,\n        xxh32,\n        xxh64,\n        init32,\n        update32,\n        digest32,\n        init64,\n        update64,\n        digest64,\n      },\n    },\n  } = await WebAssembly.instantiate(wasmBytes);\n\n  let memory = new Uint8Array(mem.buffer);\n  // Grow the wasm linear memory to accommodate length + offset bytes\n  function growMemory(length, offset) {\n    if (mem.buffer.byteLength < length + offset) {\n      const extraPages = Math.ceil(\n        // Wasm pages are spec'd to 64K\n        (length + offset - mem.buffer.byteLength) / (64 * 1024)\n      );\n      mem.grow(extraPages);\n      // After growing, the original memory's ArrayBuffer is detached, so we'll\n      // need to replace our view over it with a new one over the new backing\n      // ArrayBuffer.\n      memory = new Uint8Array(mem.buffer);\n    }\n  }\n\n  // The h32 and h64 streaming hash APIs are identical, so we can implement\n  // them both by way of a templated call to this generalized function.\n  function create(size, seed, init, update, digest, finalize) {\n    // Ensure that we've actually got enough space in the wasm memory to store\n    // the state blob for this hasher.\n    growMemory(size);\n\n    // We'll hold our hashing state in this closure.\n    const state = new Uint8Array(size);\n    memory.set(state);\n    init(0, seed);\n\n    // Each time we interact with wasm, it may have mutated our state so we'll\n    // need to read it back into our closed copy.\n    state.set(memory.slice(0, size));\n\n    return {\n      update(input) {\n        memory.set(state);\n        let length;\n        if (typeof input === \"string\") {\n          growMemory(input.length * 3, size);\n          length = encoder.encodeInto(input, memory.subarray(size)).written;\n        } else {\n          // The only other valid input type is a Uint8Array\n          growMemory(input.byteLength, size);\n          memory.set(input, size);\n          length = input.byteLength;\n        }\n        update(0, size, length);\n        state.set(memory.slice(0, size));\n        return this;\n      },\n      digest() {\n        memory.set(state);\n        return finalize(digest(0));\n      },\n    };\n  }\n\n  // Logical shift right makes it an u32, otherwise it's interpreted as an i32.\n  function forceUnsigned32(i) {\n    return i >>> 0;\n  }\n\n  // BigInts are arbitrary precision and signed, so to get the \"correct\" u64\n  // value from the return, we'll need to force that interpretation.\n  const u64Max = 2n ** 64n - 1n;\n  function forceUnsigned64(i) {\n    return i & u64Max;\n  }\n\n  const encoder = new TextEncoder();\n  const defaultSeed = 0;\n  const defaultBigSeed = 0n;\n\n  function h32(str, seed = defaultSeed) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encodeInto#buffer_sizing\n    // By sizing the buffer to 3 * string-length we guarantee that the buffer\n    // will be appropriately sized for the utf-8 encoding of the string.\n    growMemory(str.length * 3, 0);\n    return forceUnsigned32(\n      xxh32(0, encoder.encodeInto(str, memory).written, seed)\n    );\n  }\n\n  function h64(str, seed = defaultBigSeed) {\n    growMemory(str.length * 3, 0);\n    return forceUnsigned64(\n      xxh64(0, encoder.encodeInto(str, memory).written, seed)\n    );\n  }\n\n  return {\n    h32,\n    h32ToString(str, seed = defaultSeed) {\n      return h32(str, seed).toString(16).padStart(8, \"0\");\n    },\n    h32Raw(inputBuffer, seed = defaultSeed) {\n      growMemory(inputBuffer.byteLength, 0);\n      memory.set(inputBuffer);\n      return forceUnsigned32(xxh32(0, inputBuffer.byteLength, seed));\n    },\n    create32(seed = defaultSeed) {\n      return create(\n        XXH32_STATE_SIZE_BYTES,\n        seed,\n        init32,\n        update32,\n        digest32,\n        forceUnsigned32\n      );\n    },\n    h64,\n    h64ToString(str, seed = defaultBigSeed) {\n      return h64(str, seed).toString(16).padStart(16, \"0\");\n    },\n    h64Raw(inputBuffer, seed = defaultBigSeed) {\n      growMemory(inputBuffer.byteLength, 0);\n      memory.set(inputBuffer);\n      return forceUnsigned64(xxh64(0, inputBuffer.byteLength, seed));\n    },\n    create64(seed = defaultBigSeed) {\n      return create(\n        XXH64_STATE_SIZE_BYTES,\n        seed,\n        init64,\n        update64,\n        digest64,\n        forceUnsigned64\n      );\n    },\n  };\n}\n\nexport default xxhash;\n"],"names":["wasmBytes","Uint8Array","async","xxhash","instance","exports","mem","xxh32","xxh64","init32","update32","digest32","init64","update64","digest64","WebAssembly","instantiate","memory","buffer","growMemory","length","offset","byteLength","extraPages","Math","ceil","grow","create","size","seed","init","update","digest","finalize","state","set","slice","input","encoder","encodeInto","subarray","written","this","forceUnsigned32","i","u64Max","forceUnsigned64","TextEncoder","defaultBigSeed","h32","str","h64","h32ToString","toString","padStart","h32Raw","inputBuffer","create32","u32_BYTES","h64ToString","h64Raw","create64","u64_BYTES"],"mappings":"AAKA,MAAMA,EAAY,IAAIC,WAAW,05TAuBjCC,eAAeC,UAEXC,UACEC,SAASC,IACPA,EADOC,MAEPA,EAFOC,MAGPA,EAHOC,OAIPA,EAJOC,SAKPA,EALOC,SAMPA,EANOC,OAOPA,EAPOC,SAQPA,EAROC,SASPA,WAGIC,YAAYC,YAAYhB,OAE9BiB,EAAS,IAAIhB,WAAWK,EAAIY,iBAEvBC,EAAWC,EAAQC,MACtBf,EAAIY,OAAOI,WAAaF,EAASC,EAAQ,OACrCE,EAAaC,KAAKC,MAErBL,EAASC,EAASf,EAAIY,OAAOI,mBAEhChB,EAAIoB,KAAKH,GAITN,EAAS,IAAIhB,WAAWK,EAAIY,kBAMvBS,EAAOC,EAAMC,EAAMC,EAAMC,EAAQC,EAAQC,GAGhDd,EAAWS,SAGLM,EAAQ,IAAIjC,WAAW2B,UAC7BX,EAAOkB,IAAID,GACXJ,EAAK,EAAGD,GAIRK,EAAMC,IAAIlB,EAAOmB,MAAM,EAAGR,IAEnB,CACLG,OAAOM,OAEDjB,SADJH,EAAOkB,IAAID,GAEU,iBAAVG,GACTlB,EAA0B,EAAfkB,EAAMjB,OAAYQ,GAC7BR,EAASkB,EAAQC,WAAWF,EAAOpB,EAAOuB,SAASZ,IAAOa,UAG1DtB,EAAWkB,EAAMf,WAAYM,GAC7BX,EAAOkB,IAAIE,EAAOT,GAClBR,EAASiB,EAAMf,YAEjBS,EAAO,EAAGH,EAAMR,GAChBc,EAAMC,IAAIlB,EAAOmB,MAAM,EAAGR,IACnBc,MAETV,OAAM,KACJf,EAAOkB,IAAID,GACJD,EAASD,EAAO,eAMpBW,EAAgBC,UAChBA,IAAM,QAKTC,EAAS,IAAM,IAAM,YAClBC,EAAgBF,UAChBA,EAAIC,QAGPP,EAAU,IAAIS,YAEdC,EAAiB,YAEdC,EAAIC,OAAKrB,yDAHE,SAOlBV,EAAwB,EAAb+B,EAAI9B,OAAY,GACpBuB,EACLpC,EAAM,EAAG+B,EAAQC,WAAWW,EAAKjC,GAAQwB,QAASZ,aAI7CsB,EAAID,OAAKrB,yDAAOmB,SACvB7B,EAAwB,EAAb+B,EAAI9B,OAAY,GACpB0B,EACLtC,EAAM,EAAG8B,EAAQC,WAAWW,EAAKjC,GAAQwB,QAASZ,UAI/C,CACLoB,IAAAA,EACAG,YAAYF,UACHD,EAAIC,yDAvBK,GAuBMG,SAAS,IAAIC,SAAS,EAAG,MAEjDC,OAAOC,OAAa3B,yDAzBF,SA0BhBV,EAAWqC,EAAYlC,WAAY,GACnCL,EAAOkB,IAAIqB,GACJb,EAAgBpC,EAAM,EAAGiD,EAAYlC,WAAYO,KAE1D4B,kBACS9B,EArIX+B,0DAsGoB,EAkCdjD,EACAC,EACAC,EACAgC,IAGJQ,IAAAA,EACAQ,YAAYT,UACHC,EAAID,yDADWF,GACAK,SAAS,IAAIC,SAAS,GAAI,MAElDM,OAAOJ,OAAa3B,yDAAOmB,SACzB7B,EAAWqC,EAAYlC,WAAY,GACnCL,EAAOkB,IAAIqB,GACJV,EAAgBtC,EAAM,EAAGgD,EAAYlC,WAAYO,KAE1DgC,kBACSlC,EA/IXmC,0DA8IkBd,EAIZpC,EACAC,EACAC,EACAgC"}