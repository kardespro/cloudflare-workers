var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/web-sockets/src/index.ts
__export(exports, {
  CloseEvent: () => CloseEvent,
  ErrorEvent: () => ErrorEvent,
  MessageEvent: () => MessageEvent,
  WebSocket: () => WebSocket,
  WebSocketPair: () => WebSocketPair,
  WebSocketPlugin: () => WebSocketPlugin,
  coupleWebSocket: () => coupleWebSocket,
  upgradingFetch: () => upgradingFetch
});

// packages/web-sockets/src/fetch.ts
var import_url = __toModule(require("url"));
var import_core = __toModule(require("@miniflare/core"));
var import_shared3 = __toModule(require("@miniflare/shared"));
var import_ws2 = __toModule(require("ws"));

// packages/web-sockets/src/couple.ts
var import_shared2 = __toModule(require("@miniflare/shared"));
var import_ws = __toModule(require("ws"));

// packages/web-sockets/src/websocket.ts
var import_assert = __toModule(require("assert"));
var import_shared = __toModule(require("@miniflare/shared"));
var MessageEvent = class extends Event {
  data;
  constructor(type, init) {
    super(type);
    this.data = init.data;
  }
};
var CloseEvent = class extends Event {
  code;
  reason;
  wasClean;
  constructor(type, init) {
    super(type);
    this.code = init?.code ?? 1005;
    this.reason = init?.reason ?? "";
    this.wasClean = init?.wasClean ?? false;
  }
};
var ErrorEvent = class extends Event {
  error;
  constructor(type, init) {
    super(type);
    this.error = init?.error ?? null;
  }
};
var kPair = Symbol("kPair");
var kAccepted = Symbol("kAccepted");
var kCoupled = Symbol("kCoupled");
var kClosed = Symbol("kClosed");
var kClose = Symbol("kClose");
var WebSocket = class extends import_shared.InputGatedEventTarget {
  #sendQueue = [];
  [kPair];
  [kAccepted] = false;
  [kCoupled] = false;
  [kClosed] = false;
  [import_shared.kWrapListener](listener) {
    const wrappedListener = super[import_shared.kWrapListener](listener);
    const addListenerCtx = (0, import_shared.getRequestContext)();
    return (event) => {
      if (addListenerCtx?.durableObject || addListenerCtx === void 0) {
        const ctx = new import_shared.RequestContext({
          requestDepth: addListenerCtx?.requestDepth,
          pipelineDepth: addListenerCtx?.pipelineDepth,
          externalSubrequestLimit: addListenerCtx?.externalSubrequestLimit ?? import_shared.EXTERNAL_SUBREQUEST_LIMIT_BUNDLED
        });
        ctx.runWith(() => wrappedListener(event));
      } else {
        addListenerCtx.runWith(() => wrappedListener(event));
      }
    };
  }
  accept() {
    if (this[kCoupled]) {
      throw new TypeError("Can't accept() WebSocket that was already used in a response.");
    }
    if (this[kAccepted])
      return;
    this[kAccepted] = true;
    const sendQueue = this.#sendQueue;
    if (sendQueue) {
      for (const event of sendQueue)
        this.dispatchEvent(event);
      this.#sendQueue = void 0;
    }
  }
  send(message) {
    if (!this[kAccepted]) {
      throw new TypeError("You must call accept() on this WebSocket before sending messages.");
    }
    if (this[kClosed]) {
      throw new TypeError("Can't call WebSocket send() after close().");
    }
    const event = new MessageEvent("message", { data: message });
    void this.#dispatchMessageEvent(event);
  }
  async #dispatchMessageEvent(event) {
    await (0, import_shared.waitForOpenOutputGate)();
    const pair = this[kPair];
    if (pair[kAccepted]) {
      pair.dispatchEvent(event);
    } else {
      const sendQueue = pair.#sendQueue;
      (0, import_assert.default)(sendQueue !== void 0);
      sendQueue.push(event);
    }
  }
  close(code, reason) {
    if (code) {
      const validCode = code >= 1e3 && code < 5e3 && code !== 1004 && code !== 1005 && code !== 1006 && code !== 1015;
      if (!validCode)
        throw new TypeError("Invalid WebSocket close code.");
    }
    if (reason !== void 0 && code === void 0) {
      throw new TypeError("If you specify a WebSocket close reason, you must also specify a code.");
    }
    this[kClose](code, reason);
  }
  [kClose](code, reason) {
    if (!this[kAccepted]) {
      throw new TypeError("You must call accept() on this WebSocket before sending messages.");
    }
    if (this[kClosed])
      throw new TypeError("WebSocket already closed");
    this[kClosed] = true;
    this[kPair][kClosed] = true;
    void this.#dispatchCloseEvent(code, reason);
  }
  async #dispatchCloseEvent(code, reason) {
    await (0, import_shared.waitForOpenOutputGate)();
    this.dispatchEvent(new CloseEvent("close", { code, reason }));
    this[kPair].dispatchEvent(new CloseEvent("close", { code, reason }));
  }
};
var WebSocketPair = function() {
  if (!(this instanceof WebSocketPair)) {
    throw new TypeError("Failed to construct 'WebSocketPair': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  this[0] = new WebSocket();
  this[1] = new WebSocket();
  this[0][kPair] = this[1];
  this[1][kPair] = this[0];
};

// packages/web-sockets/src/couple.ts
async function coupleWebSocket(ws, pair) {
  if (pair[kCoupled]) {
    throw new TypeError("Can't return WebSocket that was already used in a response.");
  }
  if (pair[kAccepted]) {
    throw new TypeError("Can't return WebSocket in a Response after calling accept().");
  }
  ws.on("message", (message, isBinary) => {
    if (isBinary) {
      pair.send((0, import_shared2.viewToBuffer)(message));
    } else {
      pair.send(message.toString());
    }
  });
  ws.on("close", (code, reason) => {
    if (!pair[kClosed])
      pair[kClose](code, reason.toString());
  });
  ws.on("error", (error) => {
    pair.dispatchEvent(new ErrorEvent("error", { error }));
  });
  pair.addEventListener("message", (e) => {
    ws.send(e.data);
  });
  pair.addEventListener("close", (e) => {
    if (ws.readyState < import_ws.default.CLOSING) {
      if (e.code === 1005) {
        ws.close();
      } else {
        ws.close(e.code, e.reason);
      }
    }
  });
  if (ws.readyState === import_ws.default.CONNECTING) {
    await new Promise((resolve, reject) => {
      ws.once("open", () => {
        pair.accept();
        pair[kCoupled] = true;
        ws.off("close", reject);
        ws.off("error", reject);
        resolve();
      });
      ws.once("close", reject);
      ws.once("error", reject);
    });
  } else {
    pair.accept();
    pair[kCoupled] = true;
    if (ws.readyState >= import_ws.default.CLOSING) {
      throw new TypeError("Incoming WebSocket connection already closed.");
    }
  }
}

// packages/web-sockets/src/fetch.ts
async function upgradingFetch(input, init) {
  const request = new import_core.Request(input, init);
  if (request.method === "GET" && request.headers.get("upgrade") === "websocket") {
    (0, import_shared3.getRequestContext)()?.incrementExternalSubrequests();
    const url = new import_url.URL(request.url);
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      throw new TypeError(`Fetch API cannot load: ${url.toString()}.
Make sure you're using http(s):// URLs for WebSocket requests via fetch.`);
    }
    url.protocol = url.protocol.replace("http", "ws");
    const headers = {};
    let protocols;
    for (const [key, value] of request.headers.entries()) {
      if (key.toLowerCase() === "sec-websocket-protocol") {
        protocols = value.split(",").map((protocol) => protocol.trim());
      } else {
        headers[key] = value;
      }
    }
    const ws = new import_ws2.default(url, protocols, {
      followRedirects: request.redirect === "follow",
      headers
    });
    let headersResolve;
    const headersPromise = new Promise((resolve) => {
      headersResolve = resolve;
    });
    ws.once("upgrade", (req) => {
      headersResolve((0, import_core._headersFromIncomingRequest)(req));
    });
    const [worker, client] = Object.values(new WebSocketPair());
    await coupleWebSocket(ws, client);
    return new import_core.Response(null, {
      status: 101,
      webSocket: worker,
      headers: await headersPromise
    });
  }
  return import_core.fetch.call(this, request);
}

// packages/web-sockets/src/plugin.ts
var import_core2 = __toModule(require("@miniflare/core"));
var import_shared4 = __toModule(require("@miniflare/shared"));
var constructError = "Failed to construct 'WebSocket': the constructor is not implemented.";
var WebSocketPlugin = class extends import_shared4.Plugin {
  #webSockets = new Set();
  #upgradingFetch;
  constructor(ctx) {
    super(ctx);
    this.#upgradingFetch = (0, import_core2.createCompatFetch)(ctx, upgradingFetch.bind(ctx.fetchMock));
  }
  setup() {
    return {
      globals: {
        MessageEvent,
        CloseEvent,
        WebSocketPair,
        WebSocket: new Proxy(WebSocket, {
          construct() {
            throw new Error(constructError);
          },
          apply() {
            throw new Error(constructError);
          }
        }),
        fetch: this.fetch
      }
    };
  }
  fetch = async (input, init) => {
    const response = await this.#upgradingFetch(input, init);
    if (response.webSocket)
      this.#webSockets.add(response.webSocket);
    return response;
  };
  reload() {
    for (const ws of this.#webSockets) {
      if (!ws[kClosed])
        ws.close(1012, "Service Restart");
    }
    this.#webSockets.clear();
  }
  dispose() {
    return this.reload();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CloseEvent,
  ErrorEvent,
  MessageEvent,
  WebSocket,
  WebSocketPair,
  WebSocketPlugin,
  coupleWebSocket,
  upgradingFetch
});
//# sourceMappingURL=index.js.map
