/// <reference types="node" />

import { Blob as Blob_2 } from 'buffer';
import Dispatcher = require('./dispatcher');
import { ReadableStream } from 'stream/web';
import { URL as URL_2 } from 'url';
import { URLSearchParams as URLSearchParams_2 } from 'url';

declare interface BlobPropertyBag {
    type?: string
    endings?: 'native' | 'transparent'
}

declare type BodyInit =
| ArrayBuffer
| AsyncIterable<Uint8Array>
| Blob_2
| FormData
| Iterable<Uint8Array>
| NodeJS.ArrayBufferView
| URLSearchParams_2
| null
| string

declare interface BodyMixin {
    readonly body: ReadableStream | null
    readonly bodyUsed: boolean

    readonly arrayBuffer: () => Promise<ArrayBuffer>
    readonly blob: () => Promise<Blob_2>
    readonly formData: () => Promise<FormData>
    readonly json: () => Promise<unknown>
    readonly text: () => Promise<string>
}

declare interface DevOptions {
    env?: string;
    ip?: string;
    port?: number;
    inspectorPort?: number;
    localProtocol?: "http" | "https";
    assets?: string;
    site?: string;
    siteInclude?: string[];
    siteExclude?: string[];
    nodeCompat?: boolean;
    compatibilityDate?: string;
    compatibilityFlags?: string[];
    experimentalEnableLocalPersistence?: boolean;
    liveReload?: boolean;
    watch?: boolean;
    vars: {
        [key: string]: unknown;
    };
    kv?: {
        binding: string;
        id: string;
        preview_id?: string;
    }[];
    durableObjects?: {
        name: string;
        class_name: string;
        script_name?: string | undefined;
        environment?: string | undefined;
    }[];
    r2?: {
        binding: string;
        bucket_name: string;
        preview_bucket_name?: string;
    }[];
    showInteractiveDevSession?: boolean;
    logLevel?: "none" | "error" | "log" | "warn" | "debug";
    logPrefix?: string;
    inspect?: boolean;
    forceLocal?: boolean;
    enablePagesAssetsServiceBinding?: EnablePagesAssetsServiceBindingOptions;
    _?: (string | number)[];
    $0?: string;
}

declare interface EnablePagesAssetsServiceBindingOptions {
    proxyPort?: number;
    directory?: string;
}

declare class File extends Blob_2 {
    /**
     * Creates a new File instance.
     *
     * @param fileBits An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).
     * @param fileName The name of the file.
     * @param options An options object containing optional attributes for the file.
     */
    constructor(fileBits: ReadonlyArray<string | NodeJS.ArrayBufferView | Blob_2>, fileName: string, options?: FilePropertyBag)

    /**
     * Name of the file referenced by the File object.
     */
    readonly name: string

    /**
     * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.
     */
    readonly lastModified: number

    readonly [Symbol.toStringTag]: string
}

declare interface FilePropertyBag extends BlobPropertyBag {
    /**
     * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.
     */
    lastModified?: number
}

/**
 * Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using fetch().
 */
declare class FormData {
    /**
     * Appends a new value onto an existing key inside a FormData object,
     * or adds the key if it does not already exist.
     *
     * The difference between `set()` and `append()` is that if the specified key already exists, `set()` will overwrite all existing values with the new one, whereas `append()` will append the new value onto the end of the existing set of values.
     *
     * @param name The name of the field whose data is contained in `value`.
     * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
     or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.
     * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is "blob". The default filename for File objects is the file's filename.
     */
    append(name: string, value: unknown, fileName?: string): void

    /**
     * Set a new value for an existing key inside FormData,
     * or add the new field if it does not already exist.
     *
     * @param name The name of the field whose data is contained in `value`.
     * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
     or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.
     * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is "blob". The default filename for File objects is the file's filename.
     *
     */
    set(name: string, value: unknown, fileName?: string): void

    /**
     * Returns the first value associated with a given key from within a `FormData` object.
     * If you expect multiple values and want all of them, use the `getAll()` method instead.
     *
     * @param {string} name A name of the value you want to retrieve.
     *
     * @returns A `FormDataEntryValue` containing the value. If the key doesn't exist, the method returns null.
     */
    get(name: string): FormDataEntryValue | null

    /**
     * Returns all the values associated with a given key from within a `FormData` object.
     *
     * @param {string} name A name of the value you want to retrieve.
     *
     * @returns An array of `FormDataEntryValue` whose key matches the value passed in the `name` parameter. If the key doesn't exist, the method returns an empty list.
     */
    getAll(name: string): FormDataEntryValue[]

    /**
     * Returns a boolean stating whether a `FormData` object contains a certain key.
     *
     * @param name A string representing the name of the key you want to test for.
     *
     * @return A boolean value.
     */
    has(name: string): boolean

    /**
     * Deletes a key and its value(s) from a `FormData` object.
     *
     * @param name The name of the key you want to delete.
     */
    delete(name: string): void

    /**
     * Executes given callback function for each field of the FormData instance
     */
    forEach: (
    callbackfn: (value: FormDataEntryValue, key: string, iterable: FormData) => void,
    thisArg?: unknown
    ) => void

    /**
     * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all keys contained in this `FormData` object.
     * Each key is a `string`.
     */
    keys: () => SpecIterableIterator<string>

    /**
     * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all values contained in this object `FormData` object.
     * Each value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).
     */
    values: () => SpecIterableIterator<FormDataEntryValue>

    /**
     * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through the `FormData` key/value pairs.
     * The key of each pair is a string; the value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).
     */
    entries: () => SpecIterableIterator<[string, FormDataEntryValue]>

    /**
     * An alias for FormData#entries()
     */
    [Symbol.iterator]: () => SpecIterableIterator<[string, FormDataEntryValue]>

    readonly [Symbol.toStringTag]: string
}

/**
 * A `string` or `File` that represents a single value from a set of `FormData` key-value pairs.
 */
declare type FormDataEntryValue = string | File

declare class Headers implements SpecIterable<[string, string]> {
    constructor (init?: HeadersInit)
    readonly append: (name: string, value: string) => void
    readonly delete: (name: string) => void
    readonly get: (name: string) => string | null
    readonly has: (name: string) => boolean
    readonly set: (name: string, value: string) => void
    readonly forEach: (
    callbackfn: (value: string, key: string, iterable: Headers) => void,
    thisArg?: unknown
    ) => void

    readonly keys: () => SpecIterableIterator<string>
    readonly values: () => SpecIterableIterator<string>
    readonly entries: () => SpecIterableIterator<[string, string]>
    readonly [Symbol.iterator]: () => SpecIterator<[string, string]>
}

declare type HeadersInit = string[][] | Record<string, string | ReadonlyArray<string>> | Headers

declare type ReferrerPolicy =
| ''
| 'no-referrer'
| 'no-referrer-when-downgrade'
| 'origin'
| 'origin-when-cross-origin'
| 'same-origin'
| 'strict-origin'
| 'strict-origin-when-cross-origin'
| 'unsafe-url';

declare type RequestCredentials = 'omit' | 'include' | 'same-origin'

declare interface RequestInit {
    method?: string
    keepalive?: boolean
    headers?: HeadersInit
    body?: BodyInit
    redirect?: RequestRedirect
    integrity?: string
    signal?: AbortSignal
    credentials?: RequestCredentials
    mode?: RequestMode
    referrer?: string
    referrerPolicy?: ReferrerPolicy
    window?: null
    dispatcher?: Dispatcher
}

declare type RequestMode = 'cors' | 'navigate' | 'no-cors' | 'same-origin'

declare type RequestRedirect = 'error' | 'follow' | 'manual'

declare class Response implements BodyMixin {
    constructor (body?: BodyInit, init?: ResponseInit)

    readonly headers: Headers
    readonly ok: boolean
    readonly status: number
    readonly statusText: string
    readonly type: ResponseType
    readonly url: string
    readonly redirected: boolean

    readonly body: ReadableStream | null
    readonly bodyUsed: boolean

    readonly arrayBuffer: () => Promise<ArrayBuffer>
    readonly blob: () => Promise<Blob_2>
    readonly formData: () => Promise<FormData>
    readonly json: () => Promise<unknown>
    readonly text: () => Promise<string>

    readonly clone: () => Response

    static error (): Response
    static json(data: any, init?: ResponseInit): Response
    static redirect (url: string | URL_2, status: ResponseRedirectStatus): Response
}

declare interface ResponseInit {
    readonly status?: number
    readonly statusText?: string
    readonly headers?: HeadersInit
}

declare type ResponseRedirectStatus = 301 | 302 | 303 | 307 | 308

declare type ResponseType =
| 'basic'
| 'cors'
| 'default'
| 'error'
| 'opaque'
| 'opaqueredirect'

declare interface SpecIterable<T> {
    [Symbol.iterator](): SpecIterator<T>;
}

declare interface SpecIterableIterator<T> extends SpecIterator<T> {
    [Symbol.iterator](): SpecIterableIterator<T>;
}

declare interface SpecIterator<T, TReturn = any, TNext = undefined> {
    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
}

/**
 *  unstable_dev starts a wrangler dev server, and returns a promise that resolves with utility functions to interact with it.
 *  @param {string} script
 *  @param {DevOptions} options
 */
export declare function unstable_dev(script: string, options: DevOptions, disableExperimentalWarning?: boolean): Promise<{
    stop: () => void;
    fetch: (init?: RequestInit | undefined) => Promise<Response | undefined>;
    waitUntilExit: () => Promise<void>;
}>;

export { }
